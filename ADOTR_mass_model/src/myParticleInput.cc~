#include "myParticleInput.hh"
#include "myParticle.hh"
#include "myRunAction.hh"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <math.h>
#include "Randomize.hh"
#include "G4PhysicalConstants.hh"
#include "G4SystemOfUnits.hh"

using namespace std;

extern double binHigh, binLow;

myParticleInput::myParticleInput() //double BinEnergy
{
	// This part seeds the random number generator
  srand(1337); // I have seen examples use srand(time([int])), but I'm not sure if that's required yet
	
	/*
	double binHigh;
	double binLow;
	double binEnergies[] = {0.095, 0.105, 0.115, 0.125, 0.135, 0.145, 0.155, 0.165, 0.175, 0.185, 
                        0.195, 0.205, 0.215, 0.225, 0.235, 0.245, 0.260, 0.280, 0.300, 0.320, 
                        0.340, 0.360, 0.380, 0.400, 0.420, 0.440, 0.460, 0.480, 0.500, 0.520, 
                        0.540, 0.575, 0.625, 0.675, 0.725, 0.775, 0.825, 0.875, 0.925, 0.975, 
                        1.050, 1.150, 1.250, 1.350, 1.450, 1.550, 1.650, 1.750, 1.850, 1.950, 
                        2.050, 2.150, 2.250, 2.350, 2.450, 2.600, 2.800, 3.000, 3.200, 3.400, 
                        3.600, 3.800, 4.000, 4.200, 4.400, 4.600, 4.800, 5.000, 5.200, 5.400,
                        5.600, 5.800, 6.000, 6.200, 6.400, 6.600, 6.800, 7.000, 7.200, 7.400, 
                        7.750, 8.250, 8.750, 9.250, 9.750, 10.250, 10.750, 11.250, 11.750, 
                        12.250, 12.750, 13.250, 13.750, 14.250, 14.750, 15.500, 16.500, 17.500, 
                        18.500, 19.500, 20.500, 21.500, 22.500, 23.500, 24.500, 25.500, 26.500, 
                        27.500, 28.500, 29.500, 30.500, 31.500, 32.500, 33.500, 34.500, 35.500, 
                        36.500, 37.500, 38.500, 39.500, 40.500};

  // normalize input BinEnergy
    double NBinEnergy = BinEnergy / 1000;
	
  // get bin edge energies
	for (int i = 0; i < sizeof(binEnergies); i++) {
		if (binEnergies[i] > NBinEnergy) {
			binHigh = binEnergies[i];
			binLow = binEnergies[i - 1];
			break;
		}
	}
	*/
	/*
  // allocate memory
	fEvent       = new G4int[fNinput](); 
	fParticle    = new G4String[fNinput](); 
	fEnergy      = new G4double[fNinput](); 
	fArrivalTime = new G4double[fNinput](); 
	fPosX        = new double[fNinput]();
	fPosY        = new double[fNinput]();
	fPosZ        = new double[fNinput]();
	fDirX        = new double[fNinput]();
	fDirY        = new double[fNinput]();
	fDirZ        = new double[fNinput]();

	fECD         = new double[fNinput]();
	fWeight      = new double[fNinput]();

  // read input file 
  long i = 0l;
	
	string sPos;
	string sDir;
	G4double data;
	vector<G4double> vect;
	
	getline(f, line);
	while (getline(f, line)){ 

		stringstream lineStream(line);
		
		// read line data
		lineStream >> fEvent[i]
							 >> fParticle[i]
							 >> fEnergy[i]
							 >> fArrivalTime[i]
							 >> sPos >> sDir;

		// process 'sPos' and 'sDir' strings
		stringstream ssPos(sPos.erase(0, 1));			
		while (ssPos >> data)
		{	
			vect.push_back(data);
			if (ssPos.peek() == ',' || ssPos.peek() == ')') ssPos.ignore();
		}
		fPosX[i] = vect.at(0);
		fPosY[i] = vect.at(1);
		fPosZ[i] = vect.at(2);
		vect.clear();

		stringstream ssDir(sDir.erase(0, 1));			
		while (ssDir >> data)
		{	
			vect.push_back(data);
			if (ssDir.peek() == ',' || ssDir.peek() == ')') ssDir.ignore();
		}
		fDirX[i] = vect.at(0);
		fDirY[i] = vect.at(1);
		fDirZ[i] = vect.at(2);
		vect.clear();

    // calculate weighting factor, max out at 100
    fWeight[i] = 1.0/fabs(fDirZ[i]);
    if (fWeight[i] > 20.0) fWeight[i] = 20.0;

    // build the weighted emperical cumulative distribution to 
    // use to select indices from particle array
    if (i == 0)
      fECD[i] = fWeight[i];
    else 
      fECD[i] = fECD[i-1] + fWeight[i];

		G4cout << fEvent[i] << " "
					 << fParticle[i] << " "
					 << fEnergy[i] << " "
           << fArrivalTime[i] << " "
           << fPosX[i] << " "
           << fPosY[i] << " "
           << fPosZ[i] << " "
           << fDirX[i] << " "
           << fDirY[i] << " "
           << fDirZ[i] << " "
           << G4endl;

		i++;
	}
  f.close();

  // normalize the ECD to max out at 1
  for (i=0l; i<fNinput; i++)
    fECD[i] /= fECD[fNinput-1];

  cout << fNinput << " particles input from " << filename << endl;
	findx = 0l;
	*/
  
  return;
}

myParticleInput::~myParticleInput()
{
  delete[] fEvent;
  delete[] fParticle;
  delete[] fArrivalTime; 
  delete[] fEnergy;
  delete[] fPosX;
  delete[] fPosY;
  delete[] fPosZ;
  delete[] fDirX;
  delete[] fDirY;
  delete[] fDirZ;
  delete[] fECD;
  delete[] fWeight;
}

double * myParticleInput::generateParticleRands() //I don't know if this function will interefere with the below one or can use binHigh and binLow
{
    static double rands[3];
	// pick 3 random numbers between 0 and 1 then multiply it to the X and Y position and Bin energy
	// then add the 3 numbers to the fEnergy, fPosX, and fPosY
	// MAKE SURE THE SRAND() IS RUN
	
    rands[0] = binLow + ((double)rand() / RAND_MAX) * (binHigh - binLow);
    rands[1] = -0.5 + ((double)rand() / RAND_MAX);
    rands[2] = -0.5 + ((double)rand() / RAND_MAX);
    return rands;
}

myParticle myParticleInput::getParticle()
{
  // 1.  Pick a particle from the particle array according 
  // to the specified fECD
  // 2.  Specify it's direction
  // 3.  Specify it's location on the input sphere
 
  myParticle particle;

//c Pick one of the input photons randomly and set up its initial
//c parameters:

//c Select a random # from 0-1 and walk up the integral probability
//c distribution until you exceed it.  Wishing for IDL's "where" here.
//c "indx" is the photon you've picked.

  /*
  G4int nbEventInRun = myRunAction::Instance()->nbEventInRun;
  double randval = double(fpcount)/double(nbEventInRun);
  long indx = -1l;
  for (long i=findx; i < fNinput; i++){
    if (fECD[i] > randval){
			indx = i;
      break;
		}  
	}

  findx = indx;
  fpcount++;
  */

  //
  double randE = binLow + ((double)rand() / RAND_MAX) * (binHigh - binLow); //Generates random energy

  particle.set_Energy(randE); //fEnergy[indx]*eV
  particle.set_ParticleDefinition("gamma"); //fParticle[indx]
  particle.set_ArrivalTime(0.0); //fArrivalTime[indx]*ms

//c CHOOSE A DIRECTION: the third direction cosine is given, pick
//c the horizontal ones using a random azimuthal angle phi.
  
  //double zd = -1.0; //fDirZ[indx]
  //double hor = sqrt(1.0 - zd*zd);
  //double random_phi = G4UniformRand(); 
  //double phi = 2.0 * pi * random_phi;
  double dir[3] = {0.0, 0.0, -1.0}; //hor*cos(phi), hor*sin(phi), zd
  //cout << "dir*dir " << dir[0]*dir[0] + dir[1]*dir[1] + dir[2]*dir[2] << endl;
  //
  
  particle.set_StartDir(dir[0],dir[1],dir[2]); //
  //cout << "Direction " << dir[0] << " " << dir[1] << " " << dir[2] << G4endl; //

//c CHOOSE A STARTING POSITION randomly on a disk (which will be  the
//c input sphere's shadow cast by a plane wave coming in the input
//c direction generated above for the current photon:

  double random_radius = G4UniformRand();
  double random_phi2 = G4UniformRand(); 
  double r = sqrt(random_radius);
  double phi2 = 2.0 * pi * random_phi2;
  double x = r * sin(phi2);
  double y = r * cos(phi2);
  double z = -sqrt(1.0 - x*x - y*y); 

//c Transform the initial position by rotating it into the
//c reference frame defined by the incoming photon direction
//c for this photon (direction cosines are the variable dir;
//c coordinates to start the photon are cxyz; rr is the radius
//c of the sphere for photon inputs:

  double vecA[3] = {x, y, z};
  double vecB[3] = {0, 0, 0};
  double zaxis[3] = {dir[0], dir[1], dir[2]};
  double xaxis[3] = {-dir[2]/sqrt(dir[2]*dir[2]+dir[0]*dir[0]), 0.0,
                      dir[0]/sqrt(dir[2]*dir[2]+dir[0]*dir[0])};

//c SUBROUTINE TO PERFORM A ROTATION OF THREE MUTUALLY
//c ORTHOGONAL AXES.  vecA is the vector in frame A, vecB is
//c the vector in frame B (desired result) and zaxis and
//c xaxis are the coordinates of those A axes in the B frame.
//c T is a rotation matrix.

  double T[3][3];
  int i, j, k;
  for (i=0; i<3; i++){
    T[0][i] = xaxis[i];
    T[2][i] = zaxis[i];
    j = ((i+1) % 3);
    k = ((j+1) % 3);
    T[1][i] = xaxis[k]*zaxis[j] - xaxis[j]*zaxis[k];
  } 

  /*
  // check that T*transpose(T) = 1
  double I[3][3];
  double sum = 0;
  for (i=0; i<3; i++)
    for (j=0; j<3; j++){
      for (k=0; k<3; k++)
        sum = sum + T[i][k]*T[j][k];
    	I[i][j] = sum; 
    	sum = 0;
		}
 
  for (i=0; i<3; i++){
   for (j=0; j<3; j++)
     cout << I[i][j] << '\t';
   cout << endl;
  }
  */
 
  /*
  //check that det(T) = 1
  cout << T[0][0]*(T[1][1]*T[2][2] -
T[2][1]*T[1][2]) - T[0][1]*(T[1][0]*T[2][2] - T[2][0]*T[1][2]) +
          T[0][2]*(T[1][0]*T[2][1] - T[2][0]*T[1][1]) << endl;
	*/
  
  // rotate vecA
  for (i=0; i<3; i++)
    for (j=0; j<3; j++)
      vecB[i] = vecB[i] + T[j][i]*vecA[j];

  particle.set_StartXYZ(vecB[0],vecB[1],vecB[2]);
  // cout << "Vectors " << vecB[0] << " " << vecB[1] << " " << vecB[2] << G4endl; //
	return particle;
}
